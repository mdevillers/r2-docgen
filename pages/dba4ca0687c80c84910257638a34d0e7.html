<!DOCTYPE html>
<html>
| pf:pf[.k[.f[=v]]|[v]]|[n]|[0|cnt][fmt] [a0 a1 ...]  <br>Format:<br>|  b       byte (unsigned)<br>|  B       resolve enum bitfield (see t?)<br>|  c       char (signed byte)<br>|  C       byte in decimal<br>|  d       0xHEX value (4 bytes) (see 'i' and 'x')<br>|  D       disassemble one opcode<br>|  e       temporally swap endian<br>|  E       resolve enum name (see t?)<br>|  f       float value (4 bytes)<br>|  F       double value (8 bytes)<br>|  i       signed integer value (4 bytes) (see 'd' and 'x')<br>|  n       next char specifies size of signed value (1, 2, 4 or 8 byte(s))<br>|  N       next char specifies size of unsigned value (1, 2, 4 or 8 byte(s))<br>|  o       octal value (4 byte)<br>|  p       pointer reference (2, 4 or 8 bytes)<br>|  q       quadword (8 bytes)<br>|  r       CPU register `pf r (eax)plop`<br>|  s       32bit pointer to string (4 bytes)<br>|  S       64bit pointer to string (8 bytes)<br>|  t       UNIX timestamp (4 bytes)<br>|  T       show Ten first bytes of buffer<br>|  u       uleb128 (variable length)<br>|  w       word (2 bytes unsigned short in hex)<br>|  x       0xHEX value and flag (fd @ addr) (see 'd' and 'i')<br>|  X       show formatted hexpairs<br>|  z       null terminated string<br>|  Z       null terminated wide string<br>|  ?       data structure `pf ? (struct_name)example_name`<br>|  *       next char is pointer (honors asm.bits)<br>|  +       toggle show flags for each offset<br>|  :       skip 4 bytes<br>|  .       skip 1 byte<br>|  ;       rewind 4 bytes<br>|  ,       rewind 1 byte<br></html>
