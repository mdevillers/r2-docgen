analysis commands<br><br><!DOCTYPE html>
<html>
Usage: a  [abdefFghoprxstc] [...]<br>| a                  alias for aai - analysis information<br>| a*                 same as afl*;ah*;ax*<br>| aa[?]              analyze all (fcns + bbs) (aa0 to avoid sub renaming)<br>| a8 [hexpairs]      analyze bytes<br>| ab[b] [addr]       analyze block at given address<br>| abb [len]          analyze N basic blocks in [len] (section.size by default)<br>| ac[?]              manage classes<br>| aC[?]              analyze function call<br>| aCe[?]             same as aC, but uses esil with abte to emulate the function<br>| ad[?]              analyze data trampoline (wip)<br>| ad [from] [to]     analyze data pointers to (from-to)<br>| ae[?] [expr]       analyze opcode eval expression (see ao)<br>| af[?]              analyze Functions<br>| aF                 same as above, but using anal.depth=1<br>| ag[?] [options]    draw graphs in various formats<br>| ah[?]              analysis hints (force opcode size, ...)<br>| ai [addr]          address information (show perms, stack, heap, ...)<br>| aj                 same as a* but in json (aflj)<br>| aL                 list all asm/anal plugins (e asm.arch=?)<br>| an [name] [@addr]  show/rename/create whatever flag/function is used at addr<br>| ao[?] [len]        analyze Opcodes (or emulate it)<br>| aO[?] [len]        Analyze N instructions in M bytes<br>| ap                 find prelude for current offset<br>| ar[?]              like 'dr' but for the esil vm. (registers)<br>| as[?] [num]        analyze syscall using dbg.reg<br>| av[?] [.]          show vtables<br>| ax[?]              manage refs/xrefs (see also afx?)<br></html>
