analyze all (fcns + bbs) (aa0 to avoid sub renaming)<br><br><!DOCTYPE html>
<html>
Usage: aa[0*?]   # see also 'af' and 'afna'<br>| aa                  alias for 'af@@ sym.*;af@entry0;afva'<br>| aaa[?]              autoname functions after aa (see afna)<br>| aab                 abb across bin.sections.rx<br>| aac [len]           analyze function calls (af @@ `pi len~call[1]`)<br>| aac* [len]          flag function calls without performing a complete analysis<br>| aad [len]           analyze data references to code<br>| aae [len] ([addr])  analyze references with ESIL (optionally to address)<br>| aaf[e|r|t]          analyze all functions (e anal.hasnext=1;afr @@c:isq) (aafe=aef@@f)<br>| aaF [sym*]          set anal.in=block for all the spaces between flags matching glob<br>| aaFa [sym*]         same as aaF but uses af/a2f instead of af+/afb+ (slower but more accurate)<br>| aai[j]              show info of all analysis parameters<br>| aan[gr?]            autoname functions (aang = golang, aanr = noreturn propagation)<br>| aao                 analyze all objc references<br>| aap                 find and analyze function preludes<br>| aar[?] [len]        analyze len bytes of instructions for references<br>| aas [len]           analyze symbols (af @@= `isq~[0]`)<br>| aaS                 analyze all flags starting with sym. (af @@ sym.*)<br>| aat [fcn]           Analyze all/given function to convert immediate to linked structure offsets (see tl?)<br>| aaT [len]           analyze code after trap-sleds<br>| aau [len]           list mem areas (larger than len bytes) not covered by functions<br>| aav [sat]           find values referencing a specific section or map<br></html>
