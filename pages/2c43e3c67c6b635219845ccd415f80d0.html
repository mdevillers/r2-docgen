analyze Functions<br><br><!DOCTYPE html>
<html>
Usage: af  <br>| af ([name]) ([addr])                  analyze functions (start at addr or $$)<br>| afr ([name]) ([addr])                 analyze functions recursively<br>| af+ addr name [type] [diff]           hand craft a function (requires afb+)<br>| af- [addr]                            clean all function analysis data (or function at addr)<br>| afa                                   analyze function arguments in a call (afal honors dbg.funcarg)<br>| afb+ fcnA bbA sz [j] [f] ([t]( [d]))  add bb to function @ fcnaddr<br>| afb[?] [addr]                         List basic blocks of given function<br>| afbF([0|1])                           Toggle the basic-block 'folded' attribute<br>| afB 16                                set current function as thumb (change asm.bits)<br>| afC[lc] ([addr])@[addr]               calculate the Cycles (afC) or Cyclomatic Complexity (afCc)<br>| afc[?] type @[addr]                   set calling convention for function<br>| afd[addr]                             show function + delta for given offset<br>| afF[1|0|]                             fold/unfold/toggle<br>| afi [addr|fcn.name]                   show function(s) information (verbose afl)<br>| afj [tableaddr] [count]               analyze function jumptable<br>| afl[?] [ls*] [fcn name]               list functions (addr, size, bbs, name) (see afll)<br>| afm name                              merge two functions<br>| afM name                              print functions map<br>| afn[?] name [addr]                    rename name for function at address (change flag too)<br>| afna                                  suggest automatic name for current offset<br>| afo[?j] [fcn.name]                    show address for the function name or current offset<br>| afs[!] ([fcnsign])                    get/set function signature at current address (afs! uses cfg.editor)<br>| afS[stack_size]                       set stack frame size for function at current address<br>| afsr [function_name] [new_type]       change type for given function<br>| aft[?]                                type matching, type propagation<br>| afu addr                              resize and analyze function from current address until addr<br>| afv[bsra]?                            manipulate args, registers and variables in function<br>| afx                                   list function references<br></html>
